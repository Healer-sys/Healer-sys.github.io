[{"categories":["笔记"],"content":"CMakeLists.txt配置 必要三个参数 # 配置最低版本 cmake_minimum_required(VERSION 2.8.12) # 配置项目名称 project(project_name) # 配置编译器 set(CMAKE_C_COMPILER /usr/bin/aarch64-linux-gnu-gcc) # 添加可执行文件 add_executable(main main.c) 简单为项目添加构建目标 # 配置最低版本 cmake_minimum_required(VERSION 2.8.12) # 配置项目名称 project(project_name) # 配置编译器 set(CMAKE_C_COMPILER /usr/bin/aarch64-linux-gnu-gcc) # 导入头文件 include_directories(${PROJECT_SOURCE_DIR}/include) # 指定第三方库 link_libraries(lib_name1) link_libraries(lib_name2) # 指定库路径 link_directories(${PROJECT_SOURCE_DIR}/lib_path) # 指定源文件 file(GLOB_RECURSE SOURCES \"${PROJECT_SOURCE_DIR}/src/*.c\") # 添加可执行文件 add_executable(${CMAKE_PROJECT_NAME} ${SOURCES}) ","date":"2024-07-24","objectID":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/:1:0","tags":["cmake","Linux","gcc","交叉编译"],"title":"使用cmake的笔记","uri":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"配置cmake # 简单配置 cmake -S . -B build (-DCMAKE_BUILD_TYPE=Release 可有可无) # 带参数配置 cmake -DCMAKE_BUILD_TYPE:STRING=Debug // 调试 or 发布 / -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE // 生成编译命令 / -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/aarch64-linux-gnu-gcc // 指定编译器 / --no-warn-unused-cli // 忽略未使用的参数 / -S/your_project_path // 源码路径 / -B/your_project_path/build // 构建路径 / -G Ninja // 使用Ninja构建 ","date":"2024-07-24","objectID":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/:2:0","tags":["cmake","Linux","gcc","交叉编译"],"title":"使用cmake的笔记","uri":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"构建 cmake --build build // 构建 # 补充 cmake --build build --target all // 构建全部 cmake --build build --target clean // 清空构建 cmake --build build --target install // 安装 cmake --build build --target uninstall // 卸载 cmake --build build --target run // 运行 cmake --build build --target test // 测试 cmake --build build --target package // 打包 cmake --build build --target package_source // 打包源码 ","date":"2024-07-24","objectID":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/:3:0","tags":["cmake","Linux","gcc","交叉编译"],"title":"使用cmake的笔记","uri":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"添加运行/调试需要传入的参数 1. 直接使用cmake tool调试，需要给cmake传入参数，在Settings.json中添加以下内容\r```\r\"cmake.debugConfig\": {\r\"args\": [\r\"arg1\",\r\"arg2\",\r\"....\"\r]\r}\r```\r2. 如果是vscode gdb 启动，需要添加启动配置，可以在launch.json中添加设置(运行环境是./vscode)\r\u003e 有空可以研究一下vscode的三个配置文件(tasks.json, launch.json, settings.json)\r建议使用vscode+cmake插件 因为cmake插件可以快捷设置cmake参数，自动生成编译命令，可以实时编译 可以用cmake插件生成调试配置，用vscode调试可以图形化显示变量，添加断点，单步运行，更简单直观调试流程 ","date":"2024-07-24","objectID":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/:4:0","tags":["cmake","Linux","gcc","交叉编译"],"title":"使用cmake的笔记","uri":"/posts/%E4%BD%BF%E7%94%A8cmake%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"1. 查看交叉编译工具链的搜索路径 /usr/lib/gcc-cross/aarch64-linux-gnu/11/../../../../aarch64-linux-gnu/bin/ld --verbose | grep SEARCH_DIR ","date":"2024-07-24","objectID":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/:1:0","tags":["Linux","gcc","交叉编译"],"title":"交叉编译","uri":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"categories":["笔记"],"content":"2. 添加交叉编译工具链的搜索路径 ","date":"2024-07-24","objectID":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/:2:0","tags":["Linux","gcc","交叉编译"],"title":"交叉编译","uri":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"categories":["笔记"],"content":"方法一 # 添加链接库的搜索路径 gcc -L/Your_Path/lib .... ","date":"2024-07-24","objectID":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/:2:1","tags":["Linux","gcc","交叉编译"],"title":"交叉编译","uri":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"categories":["笔记"],"content":"方法二 添加变量 # 程序编译时搜索的库路径，即指定gcc编译需要链接动态链接库的目录 export LIBRARY_PATH=/Your_Path/lib:$LIBRARY_PATH # 编译时搜索的头文件路径 export C_INCLUDE_PATH=/Your_Path/lib:$C_INCLUDE_PATH # 程序运行时搜索的库路径 export LD_LIBRARY_PATH=/Your_Path/lib:$LD_LIBRARY_PATH ","date":"2024-07-24","objectID":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/:2:2","tags":["Linux","gcc","交叉编译"],"title":"交叉编译","uri":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"categories":["笔记"],"content":"终极绝招，修改链接器缓存 使用GCC编译动态链接库的项目时，在其他目录下执行很可以出现找不到动态链接库的问题。 这种情况多发生在动态链接库是自己开发的情况下，原因就是程序运行时找不到去何处加载动态链接库。 可能会说在编译时指定了链接的目录啊！编译时指定的 -L的目录，只是在程序链接成可执行文件时使用的。程序执行时动态链接库加载不到动态链接库。 解决办法有两种，第一程序链接时指定链接库的位置，就是使用-wl,-rpath=\u003clink_path\u003e参数，\u003clink_path\u003e就是链接库的路径。如： gcc -o foo foo.c -L. -lfoo -Wl,-rpath=./ 上面就是指定了链接的位置在当前目录，这种情况只有在当前目录执行./foo时，才是可以正确使用的。一般情况我们使用如下格式： gcc -o foo foo.c -L$(prefix)/lib -lfoo -Wl,-rpath=$(prefix)/lib 第二种方式就是，将链接库的目录添加到/etc/ld.so.conf文件中或者添加到/etc/ld.so.conf.d/*.conf中，然后使用ldconfig进行更新，进行动态链接库的运行时动态绑定。如： 添加文件/etc/ld.so.conf.d/foo.conf，内容如下： /your path/lib 然后执行如下命令： ldconfig 参考文章: Re: linking with -Wl,-rpath and $(prefix) ","date":"2024-07-24","objectID":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/:2:3","tags":["Linux","gcc","交叉编译"],"title":"交叉编译","uri":"/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"categories":["笔记"],"content":"配置linux的环境变量 ","date":"2024-07-24","objectID":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:0:0","tags":["Linux","操作系统","环境变量"],"title":"配置环境变量","uri":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["笔记"],"content":"第一级，临时环境变量 临时环境变量，仅当前目录下的终端有效，但是当终端关闭的时候，就会失效。 export PATH=$PATH:‘your path’ 在目录下，添加到配置文件，当终端关闭的时候，乃然有效，重新打开会自动生效。 创建文件 vim .bashrc 添加内容，在底部添加以下内容，然后保存退出。 export PATH=$PATH:‘your path’ 添加内容之后，配置还没有生效，需要刷新配置文件，可以重新打开终端，或者执行以下命令 source .bashrc # 或者 source等同于 .(点) . .bashrc ","date":"2024-07-24","objectID":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:1:0","tags":["Linux","操作系统","环境变量"],"title":"配置环境变量","uri":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["笔记"],"content":"第二级，用户级的永久环境变量 在根目录下，创建配置文件，即Home目录下的.bashrc文件，可以理解成根目录到Home目录，都是用户级的配置文件。同理可以配置单个用户的环境变量。在Home目录下的用户目录创建.bashrc文件，添加内容，然后刷新配置文件。 创建文件 # 全部用户生效 cd home vim .bashrc 或者 vim ~/.bashrc # 单个用户生效 vim /home/用户名/.bashrc 在 .bashrc 文件的最后加入环境变量 export PATH=$PATH:‘your path’ 保存并退出,刷新配置文件 :wq source .bashrc ","date":"2024-07-24","objectID":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:2:0","tags":["Linux","操作系统","环境变量"],"title":"配置环境变量","uri":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["笔记"],"content":"第三级，系统级的永久环境变量 系统级的环境变量，可以理解成全局的配置文件，所有用户都可以使用。 创建文件 vim /etc/profile 在 /etc/profile 文件的最后加入环境变量 export PATH=$PATH:‘your path’ 保存并退出,刷新配置文件 :wq source /etc/profile bb $的意思是取变量器，比如$PATH，表示取PATH这个变量的值，$PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\rPATH=$PATH:，可以理解为在内容后追加\r可以用命令：echo $PATH，来显示环境变量的值\rexport\rsource .bashrc可以重复使用，用完可以看看export有什么变化\r","date":"2024-07-24","objectID":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:3:0","tags":["Linux","操作系统","环境变量"],"title":"配置环境变量","uri":"/posts/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Gie经验"],"content":"Git撤销对远程仓库的push\u0026commit提交 ","date":"2024-07-23","objectID":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/:0:0","tags":["Git"],"title":"总结一些Gie经验","uri":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/"},{"categories":["Gie经验"],"content":"撤销push 执行 git log查看日志，获取需要回退的版本号 执行 git reset –-soft \u003c版本号\u003e ，如 git reset –soft 4f5e9a90edeadcc45d85f43bd861a837fa7ce4c7 ，重置至指定版本的提交，达到撤销提交的目的 然后执行 git log 查看 此时，已重置至指定版本的提交，log中已经没有了需要撤销的提交 git reset 命令分为两种： git reset –-soft 与 git reset –-hard ，区别是： 前者表示只是改变了HEAD的指向，本地代码不会变化，我们使用git status依然可以看到，同时也可以git commit提交。后者直接回改变本地源码，不仅仅指向变化了，代码也回到了那个版本时的代码。 执行 git push origin 分支名 –force ，强制提交当前版本号。 至此，撤销push提交完成。 ","date":"2024-07-23","objectID":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/:1:0","tags":["Git"],"title":"总结一些Gie经验","uri":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/"},{"categories":["Gie经验"],"content":"撤销commit 执行 git log 查看需要撤销的commit的前面一个提交版本的id； 执行 git reset –hard commit_id ，该commit_id为需要撤销的commit的提交的前面一个提交的版本，即需要恢复到的提交的id，重置至指定版本的提交，达到撤销提交的目的 执行 git log 查看，commit提交已撤销 添加多个远程仓库 ","date":"2024-07-23","objectID":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/:2:0","tags":["Git"],"title":"总结一些Gie经验","uri":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/"},{"categories":["Gie经验"],"content":"修改config文件 定位到.git/config [remote “origin”] 远程： url：推送地址 fetch：拉取地址 添加remote里面的url，如gitee仓库 push同步提交 git push origin 4. 至此，添加多个远程仓库完成。 查看分支和切换分支 ","date":"2024-07-23","objectID":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/:3:0","tags":["Git"],"title":"总结一些Gie经验","uri":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/"},{"categories":["Gie经验"],"content":"查看分支 git branch -a ","date":"2024-07-23","objectID":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/:4:0","tags":["Git"],"title":"总结一些Gie经验","uri":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/"},{"categories":["Gie经验"],"content":"切换分支 git checkout branchName git拉取、推送所有分支及标签 从origin1推送到origin2 git push origin2 'refs/remotes/origin1/*:refs/heads/*' # 推送后带有后缀demo01 git push origin2'refs/remotes/origin1/*:refs/heads/demo01/*' # 推送指定分支 git push origin2 'refs/remotes/origin1/dev:refs/heads/dev' 拉取所有分支到本地 git branch -r | grep -v '\\-\u003e' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done git fetch --all git pull --all 拉取所有标签到本地 git fetch origin --prune 切换远程仓库 推送所有分支 git push --mirror 推送所有标签 git push origin --tags git迁移脚本 #!/bin/bash export oldUrl=$1 export newUrl=$2 export repoName=$3 printf \"oldUrl: %s\\nnewUrl: %s\\nrepoName: %s\\n\" $oldUrl $newUrl $repoName [[ -z \"${oldUrl}\" ]] \u0026\u0026 echo \"不能为空\" \u0026\u0026 exit [[ -z \"${newUrl}\" ]] \u0026\u0026 echo \"不能为空\" \u0026\u0026 exit [[ -z \"${repoName}\" ]] \u0026\u0026 echo \"不能为空\" \u0026\u0026 exit printf \"克隆原仓库\" cd repo || exit git.exe clone --progress -v \"${oldUrl}\" cd ${repoName} || exit #git branch -r | grep -v '\\-\u003e' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done #git fetch --all #git pull --all #git fetch origin --prune # 原仓库 # dev -\u003e dev-origin # git remote change new repo echo \"增加新仓库\" git remote rename origin origin-old git remote add origin \"${newUrl}\" echo \"拉取所有仓库分支\" git fetch origin git fetch origin-old echo \"删除本地dev分支\" git branch -D dev # origin/dev -\u003e origin/dev-bak echo \"备份分支\" git checkout -b dev-origin origin-old/dev git checkout -b dev-yanshi4-11 origin-old/yanshi4-11 git checkout -b dev-bak origin/dev echo \"新仓库切出dev分支\" git checkout -b dev origin/dev echo \"复制ci配置到临时文件\" mkdir -p ../tmp/ || exit cp .gitlab-ci.yml Dockerfile ../tmp/ || exit echo \"切回旧仓库dev分支\" git checkout master git branch -D dev git checkout -b dev origin-old/yanshi4-11 echo \"配置ci配置\" mv -f ../tmp/* ./ || exit mv -f ../tmp/.gitlab-ci.yml ./ || exit git add . git commit -m \"ci适配\" echo \"删除旧仓库远程配置，防止误删\" git remote remove origin-old echo \"推送所有分支\" git push --progress \"origin\" dev-origin git push --progress \"origin\" dev-yanshi4-11 git push --progress \"origin\" dev-bak git push --force --progress \"origin\" dev:dev ","date":"2024-07-23","objectID":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/:5:0","tags":["Git"],"title":"总结一些Gie经验","uri":"/posts/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9Bgie%E7%BB%8F%E9%AA%8C/"},{"categories":null,"content":" 展开听音乐 🎵🎶 博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 信息 一个 信息 横幅 ","date":"2024-07-21","objectID":"/posts/583bc6c/:0:0","tags":null,"title":"我的第一篇文章","uri":"/posts/583bc6c/"},{"categories":null,"content":" /** * 建站的初衷不是为了炫耀所知，而是记录无知。 * 人知道的越多，就会发现无知的越多。有更广袤的世界可以探索，是莫大的快乐！ * @since 2018-05-28 20:01:01 */ class Blog { constructor(name, author, url) { this.name = name; this.author = author; this.url = url; } } const site = new Blog('skylar的博客', '莫德飞', 'https://healer-sys.github.io/'); ","date":"2021-09-07","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者 👨‍💻 正在完善中… 信息 来听我喜欢的歌单吧 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"}]